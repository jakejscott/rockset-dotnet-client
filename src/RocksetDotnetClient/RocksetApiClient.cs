//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace RocksetDotnetClient
{
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IRocksetApiClient
    {
        /// <summary>Get Organization</summary>
        /// <returns>organization retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OrganizationResponse> GetOrganizationAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Organization</summary>
        /// <returns>organization retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OrganizationResponse> GetOrganizationAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Collections</summary>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListCollectionsResponse> ListCollectionsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Collections</summary>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListCollectionsResponse> ListCollectionsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Integrations</summary>
        /// <returns>integrations retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListIntegrationsResponse> ListIntegrationsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Integrations</summary>
        /// <returns>integrations retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListIntegrationsResponse> ListIntegrationsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create Integration</summary>
        /// <param name="body">integration credentials</param>
        /// <returns>integration created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateIntegrationResponse> CreateIntegrationAsync(CreateIntegrationRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Integration</summary>
        /// <param name="body">integration credentials</param>
        /// <returns>integration created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateIntegrationResponse> CreateIntegrationAsync(CreateIntegrationRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetIntegrationResponse> GetIntegrationAsync(string integration);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetIntegrationResponse> GetIntegrationAsync(string integration, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteIntegrationResponse> DeleteIntegrationAsync(string integration);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteIntegrationResponse> DeleteIntegrationAsync(string integration, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Query Lambdas</summary>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdasResponse> ListAllQueryLambdasAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambdas</summary>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdasResponse> ListAllQueryLambdasAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Query Lambda Tags</summary>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListOrganizationTagsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Tags</summary>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListOrganizationTagsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Query Lambda Tag Versions</summary>
        /// <param name="tag">name of the tag</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaTagVersionsAsync(string tag);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Tag Versions</summary>
        /// <param name="tag">name of the tag</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaTagVersionsAsync(string tag, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Query</summary>
        /// <param name="body">JSON object</param>
        /// <returns>query executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryResponse> QueryAsync(QueryRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query</summary>
        /// <param name="body">JSON object</param>
        /// <returns>query executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryResponse> QueryAsync(QueryRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Users</summary>
        /// <returns>users retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListUsersResponse> ListUsersAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Users</summary>
        /// <returns>users retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListUsersResponse> ListUsersAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create User</summary>
        /// <param name="body">JSON object</param>
        /// <returns>user created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateUserResponse> CreateUserAsync(CreateUserRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create User</summary>
        /// <param name="body">JSON object</param>
        /// <returns>user created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateUserResponse> CreateUserAsync(CreateUserRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Current User</summary>
        /// <returns>user retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<User> GetCurrentUserAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Current User</summary>
        /// <returns>user retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<User> GetCurrentUserAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List API Keys</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List API Keys</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create API Key</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAsync(CreateApiKeyRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create API Key</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAsync(CreateApiKeyRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete API Key</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAsync(string name);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete API Key</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAsync(string name, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete User</summary>
        /// <param name="user">user email</param>
        /// <returns>user deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteUserResponse> DeleteUserAsync(string user);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete User</summary>
        /// <param name="user">user email</param>
        /// <returns>user deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteUserResponse> DeleteUserAsync(string user, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List API Keys for any user (admin only)</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAdminAsync(string user);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List API Keys for any user (admin only)</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAdminAsync(string user, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create API Key for any user (admin only)</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAdminAsync(CreateApiKeyRequest body, string user);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create API Key for any user (admin only)</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAdminAsync(CreateApiKeyRequest body, string user, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete API Key for any user (admin only)</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAdminAsync(string name, string user);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete API Key for any user (admin only)</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAdminAsync(string name, string user, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Workspaces</summary>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListWorkspacesResponse> ListWorkspacesAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Workspaces</summary>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListWorkspacesResponse> ListWorkspacesAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create Workspace</summary>
        /// <param name="body">workspace details</param>
        /// <returns>workspace created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateWorkspaceResponse> CreateWorkspaceAsync(CreateWorkspaceRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Workspace</summary>
        /// <param name="body">workspace details</param>
        /// <returns>workspace created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateWorkspaceResponse> CreateWorkspaceAsync(CreateWorkspaceRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetWorkspaceResponse> GetWorkspaceAsync(string workspace);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetWorkspaceResponse> GetWorkspaceAsync(string workspace, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteWorkspaceResponse> DeleteWorkspaceAsync(string workspace);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteWorkspaceResponse> DeleteWorkspaceAsync(string workspace, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Collections for Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListCollectionsResponse> WorkspaceCollectionsAsync(string workspace);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Collections for Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListCollectionsResponse> WorkspaceCollectionsAsync(string workspace, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>collection created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateCollectionResponse> CreateCollectionAsync(string workspace, CreateCollectionRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>collection created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateCollectionResponse> CreateCollectionAsync(string workspace, CreateCollectionRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetCollectionResponse> GetCollectionAsync(string workspace, string collection);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetCollectionResponse> GetCollectionAsync(string workspace, string collection, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteCollectionResponse> DeleteCollectionAsync(string workspace, string collection);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteCollectionResponse> DeleteCollectionAsync(string workspace, string collection, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Add Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents added successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AddDocumentsResponse> AddDocumentsAsync(string workspace, string collection, AddDocumentsRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents added successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AddDocumentsResponse> AddDocumentsAsync(string workspace, string collection, AddDocumentsRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteDocumentsResponse> DeleteDocumentsAsync(string workspace, string collection, DeleteDocumentsRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteDocumentsResponse> DeleteDocumentsAsync(string workspace, string collection, DeleteDocumentsRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Patch Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON Patch objects</param>
        /// <returns>Documents patched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PatchDocumentsResponse> PatchDocumentsAsync(string workspace, string collection, PatchDocumentsRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Patch Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON Patch objects</param>
        /// <returns>Documents patched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PatchDocumentsResponse> PatchDocumentsAsync(string workspace, string collection, PatchDocumentsRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>Query Lambdas fetched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdasInCollectionAsync(string workspace, string collection);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>Query Lambdas fetched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdasInCollectionAsync(string workspace, string collection, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdasResponse> ListQueryLambdasInWorkspaceAsync(string workspace);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdasResponse> ListQueryLambdasInWorkspaceAsync(string workspace, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> CreateQueryLambdaAsync(string workspace, CreateQueryLambdaRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> CreateQueryLambdaAsync(string workspace, CreateQueryLambdaRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>Query Lambda deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteQueryLambdaResponse> DeleteQueryLambdaAsync(string workspace, string queryLambda);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>Query Lambda deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteQueryLambdaResponse> DeleteQueryLambdaAsync(string workspace, string queryLambda, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Query Lambda Tags</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListQueryLambdaTagsAsync(string workspace, string queryLambda);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Tags</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListQueryLambdaTagsAsync(string workspace, string queryLambda, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>tag created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaTagResponse> CreateQueryLambdaTagAsync(string workspace, string queryLambda, CreateQueryLambdaTagRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>tag created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaTagResponse> CreateQueryLambdaTagAsync(string workspace, string queryLambda, CreateQueryLambdaTagRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>version retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaTagResponse> GetQueryLambdaTagVersionAsync(string workspace, string queryLambda, string tag);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>version retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaTagResponse> GetQueryLambdaTagVersionAsync(string workspace, string queryLambda, string tag, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Run Query Lambda By Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">tag</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaByTagAsync(string workspace, string queryLambda, string tag, ExecuteQueryLambdaRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Run Query Lambda By Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">tag</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaByTagAsync(string workspace, string queryLambda, string tag, ExecuteQueryLambdaRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete Query Lambda Tag Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>tag deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaTagResponse> DeleteQueryLambdaTagAsync(string workspace, string queryLambda, string tag);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Query Lambda Tag Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>tag deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaTagResponse> DeleteQueryLambdaTagAsync(string workspace, string queryLambda, string tag, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Delete Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda version deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> DeleteQueryLambdaVersionAsync(string workspace, string queryLambda, string version);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda version deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> DeleteQueryLambdaVersionAsync(string workspace, string queryLambda, string version, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Query Lambda Versions</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaVersionsAsync(string workspace, string queryLambda);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Versions</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaVersionsAsync(string workspace, string queryLambda, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Update Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda updated successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> UpdateQueryLambdaAsync(string workspace, string queryLambda, UpdateQueryLambdaRequest body, bool? create);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda updated successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> UpdateQueryLambdaAsync(string workspace, string queryLambda, UpdateQueryLambdaRequest body, bool? create, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> GetQueryLambdaVersionAsync(string workspace, string queryLambda, string version);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryLambdaVersionResponse> GetQueryLambdaVersionAsync(string workspace, string queryLambda, string version, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Run Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaAsync(string workspace, string queryLambda, string version, ExecuteQueryLambdaRequest body);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Run Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaAsync(string workspace, string queryLambda, string version, ExecuteQueryLambdaRequest body, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>List Workspaces</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListWorkspacesResponse> ChildWorkspacesAsync(string workspace);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Workspaces</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ListWorkspacesResponse> ChildWorkspacesAsync(string workspace, System.Threading.CancellationToken cancellationToken);
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class RocksetApiClient : IRocksetApiClient
    {
        private string _baseUrl = "https://api.rs2.usw2.rockset.com";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public RocksetApiClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }
    
        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
    
        public Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Get Organization</summary>
        /// <returns>organization retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OrganizationResponse> GetOrganizationAsync()
        {
            return GetOrganizationAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Organization</summary>
        /// <returns>organization retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<OrganizationResponse> GetOrganizationAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OrganizationResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OrganizationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Collections</summary>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListCollectionsResponse> ListCollectionsAsync()
        {
            return ListCollectionsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Collections</summary>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListCollectionsResponse> ListCollectionsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/collections");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListCollectionsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListCollectionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Integrations</summary>
        /// <returns>integrations retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListIntegrationsResponse> ListIntegrationsAsync()
        {
            return ListIntegrationsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Integrations</summary>
        /// <returns>integrations retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListIntegrationsResponse> ListIntegrationsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/integrations");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListIntegrationsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListIntegrationsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create Integration</summary>
        /// <param name="body">integration credentials</param>
        /// <returns>integration created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CreateIntegrationResponse> CreateIntegrationAsync(CreateIntegrationRequest body)
        {
            return CreateIntegrationAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Integration</summary>
        /// <param name="body">integration credentials</param>
        /// <returns>integration created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CreateIntegrationResponse> CreateIntegrationAsync(CreateIntegrationRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/integrations");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateIntegrationResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(CreateIntegrationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GetIntegrationResponse> GetIntegrationAsync(string integration)
        {
            return GetIntegrationAsync(integration, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GetIntegrationResponse> GetIntegrationAsync(string integration, System.Threading.CancellationToken cancellationToken)
        {
            if (integration == null)
                throw new System.ArgumentNullException("integration");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/integrations/{integration}");
            urlBuilder_.Replace("{integration}", System.Uri.EscapeDataString(ConvertToString(integration, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetIntegrationResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(GetIntegrationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteIntegrationResponse> DeleteIntegrationAsync(string integration)
        {
            return DeleteIntegrationAsync(integration, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Integration</summary>
        /// <param name="integration">name of the integration</param>
        /// <returns>integration deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteIntegrationResponse> DeleteIntegrationAsync(string integration, System.Threading.CancellationToken cancellationToken)
        {
            if (integration == null)
                throw new System.ArgumentNullException("integration");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/integrations/{integration}");
            urlBuilder_.Replace("{integration}", System.Uri.EscapeDataString(ConvertToString(integration, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteIntegrationResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteIntegrationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Query Lambdas</summary>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListQueryLambdasResponse> ListAllQueryLambdasAsync()
        {
            return ListAllQueryLambdasAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambdas</summary>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListQueryLambdasResponse> ListAllQueryLambdasAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/lambdas");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListQueryLambdasResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListQueryLambdasResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Query Lambda Tags</summary>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListOrganizationTagsAsync()
        {
            return ListOrganizationTagsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Tags</summary>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListOrganizationTagsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/lambdas/tags");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListQueryLambdaTagsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListQueryLambdaTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Query Lambda Tag Versions</summary>
        /// <param name="tag">name of the tag</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaTagVersionsAsync(string tag)
        {
            return ListQueryLambdaTagVersionsAsync(tag, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Tag Versions</summary>
        /// <param name="tag">name of the tag</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaTagVersionsAsync(string tag, System.Threading.CancellationToken cancellationToken)
        {
            if (tag == null)
                throw new System.ArgumentNullException("tag");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/lambdas/tags/{tag}");
            urlBuilder_.Replace("{tag}", System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListQueryLambdaVersionsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListQueryLambdaVersionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Query</summary>
        /// <param name="body">JSON object</param>
        /// <returns>query executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryResponse> QueryAsync(QueryRequest body)
        {
            return QueryAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query</summary>
        /// <param name="body">JSON object</param>
        /// <returns>query executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryResponse> QueryAsync(QueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/queries");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Users</summary>
        /// <returns>users retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListUsersResponse> ListUsersAsync()
        {
            return ListUsersAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Users</summary>
        /// <returns>users retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListUsersResponse> ListUsersAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListUsersResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListUsersResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create User</summary>
        /// <param name="body">JSON object</param>
        /// <returns>user created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CreateUserResponse> CreateUserAsync(CreateUserRequest body)
        {
            return CreateUserAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create User</summary>
        /// <param name="body">JSON object</param>
        /// <returns>user created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CreateUserResponse> CreateUserAsync(CreateUserRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateUserResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(CreateUserResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Current User</summary>
        /// <returns>user retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<User> GetCurrentUserAsync()
        {
            return GetCurrentUserAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Current User</summary>
        /// <returns>user retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<User> GetCurrentUserAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/self");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<User>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(User);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List API Keys</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAsync()
        {
            return ListApiKeysAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List API Keys</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/self/apikeys");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListApiKeysResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListApiKeysResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create API Key</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAsync(CreateApiKeyRequest body)
        {
            return CreateApiKeyAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create API Key</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAsync(CreateApiKeyRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/self/apikeys");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateApiKeyResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(CreateApiKeyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete API Key</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAsync(string name)
        {
            return DeleteApiKeyAsync(name, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete API Key</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/self/apikeys/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteApiKeyResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteApiKeyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete User</summary>
        /// <param name="user">user email</param>
        /// <returns>user deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteUserResponse> DeleteUserAsync(string user)
        {
            return DeleteUserAsync(user, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete User</summary>
        /// <param name="user">user email</param>
        /// <returns>user deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteUserResponse> DeleteUserAsync(string user, System.Threading.CancellationToken cancellationToken)
        {
            if (user == null)
                throw new System.ArgumentNullException("user");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/{user}");
            urlBuilder_.Replace("{user}", System.Uri.EscapeDataString(ConvertToString(user, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteUserResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteUserResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List API Keys for any user (admin only)</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAdminAsync(string user)
        {
            return ListApiKeysAdminAsync(user, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List API Keys for any user (admin only)</summary>
        /// <returns>API keys retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListApiKeysResponse> ListApiKeysAdminAsync(string user, System.Threading.CancellationToken cancellationToken)
        {
            if (user == null)
                throw new System.ArgumentNullException("user");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/{user}/apikeys");
            urlBuilder_.Replace("{user}", System.Uri.EscapeDataString(ConvertToString(user, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListApiKeysResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListApiKeysResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create API Key for any user (admin only)</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAdminAsync(CreateApiKeyRequest body, string user)
        {
            return CreateApiKeyAdminAsync(body, user, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create API Key for any user (admin only)</summary>
        /// <param name="body">JSON object</param>
        /// <returns>API key created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CreateApiKeyResponse> CreateApiKeyAdminAsync(CreateApiKeyRequest body, string user, System.Threading.CancellationToken cancellationToken)
        {
            if (user == null)
                throw new System.ArgumentNullException("user");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/{user}/apikeys");
            urlBuilder_.Replace("{user}", System.Uri.EscapeDataString(ConvertToString(user, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateApiKeyResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(CreateApiKeyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete API Key for any user (admin only)</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAdminAsync(string name, string user)
        {
            return DeleteApiKeyAdminAsync(name, user, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete API Key for any user (admin only)</summary>
        /// <param name="name">name of the API key</param>
        /// <returns>API key deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteApiKeyResponse> DeleteApiKeyAdminAsync(string name, string user, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");
    
            if (user == null)
                throw new System.ArgumentNullException("user");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/users/{user}/apikeys/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{user}", System.Uri.EscapeDataString(ConvertToString(user, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteApiKeyResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteApiKeyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Workspaces</summary>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListWorkspacesResponse> ListWorkspacesAsync()
        {
            return ListWorkspacesAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Workspaces</summary>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListWorkspacesResponse> ListWorkspacesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListWorkspacesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListWorkspacesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create Workspace</summary>
        /// <param name="body">workspace details</param>
        /// <returns>workspace created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CreateWorkspaceResponse> CreateWorkspaceAsync(CreateWorkspaceRequest body)
        {
            return CreateWorkspaceAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Workspace</summary>
        /// <param name="body">workspace details</param>
        /// <returns>workspace created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CreateWorkspaceResponse> CreateWorkspaceAsync(CreateWorkspaceRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateWorkspaceResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(CreateWorkspaceResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GetWorkspaceResponse> GetWorkspaceAsync(string workspace)
        {
            return GetWorkspaceAsync(workspace, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GetWorkspaceResponse> GetWorkspaceAsync(string workspace, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetWorkspaceResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(GetWorkspaceResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteWorkspaceResponse> DeleteWorkspaceAsync(string workspace)
        {
            return DeleteWorkspaceAsync(workspace, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspace deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteWorkspaceResponse> DeleteWorkspaceAsync(string workspace, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteWorkspaceResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteWorkspaceResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Collections for Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListCollectionsResponse> WorkspaceCollectionsAsync(string workspace)
        {
            return WorkspaceCollectionsAsync(workspace, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Collections for Workspace</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>collections retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListCollectionsResponse> WorkspaceCollectionsAsync(string workspace, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListCollectionsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListCollectionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>collection created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CreateCollectionResponse> CreateCollectionAsync(string workspace, CreateCollectionRequest body)
        {
            return CreateCollectionAsync(workspace, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>collection created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CreateCollectionResponse> CreateCollectionAsync(string workspace, CreateCollectionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateCollectionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(CreateCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GetCollectionResponse> GetCollectionAsync(string workspace, string collection)
        {
            return GetCollectionAsync(workspace, collection, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GetCollectionResponse> GetCollectionAsync(string workspace, string collection, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (collection == null)
                throw new System.ArgumentNullException("collection");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections/{collection}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collection}", System.Uri.EscapeDataString(ConvertToString(collection, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetCollectionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(GetCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteCollectionResponse> DeleteCollectionAsync(string workspace, string collection)
        {
            return DeleteCollectionAsync(workspace, collection, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Collection</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>collection deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteCollectionResponse> DeleteCollectionAsync(string workspace, string collection, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (collection == null)
                throw new System.ArgumentNullException("collection");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections/{collection}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collection}", System.Uri.EscapeDataString(ConvertToString(collection, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteCollectionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteCollectionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Add Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents added successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AddDocumentsResponse> AddDocumentsAsync(string workspace, string collection, AddDocumentsRequest body)
        {
            return AddDocumentsAsync(workspace, collection, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents added successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AddDocumentsResponse> AddDocumentsAsync(string workspace, string collection, AddDocumentsRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (collection == null)
                throw new System.ArgumentNullException("collection");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections/{collection}/docs");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collection}", System.Uri.EscapeDataString(ConvertToString(collection, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AddDocumentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(AddDocumentsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteDocumentsResponse> DeleteDocumentsAsync(string workspace, string collection, DeleteDocumentsRequest body)
        {
            return DeleteDocumentsAsync(workspace, collection, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON object</param>
        /// <returns>documents deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteDocumentsResponse> DeleteDocumentsAsync(string workspace, string collection, DeleteDocumentsRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (collection == null)
                throw new System.ArgumentNullException("collection");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections/{collection}/docs");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collection}", System.Uri.EscapeDataString(ConvertToString(collection, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteDocumentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteDocumentsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Patch Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON Patch objects</param>
        /// <returns>Documents patched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PatchDocumentsResponse> PatchDocumentsAsync(string workspace, string collection, PatchDocumentsRequest body)
        {
            return PatchDocumentsAsync(workspace, collection, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Patch Documents</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <param name="body">JSON Patch objects</param>
        /// <returns>Documents patched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PatchDocumentsResponse> PatchDocumentsAsync(string workspace, string collection, PatchDocumentsRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (collection == null)
                throw new System.ArgumentNullException("collection");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections/{collection}/docs");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collection}", System.Uri.EscapeDataString(ConvertToString(collection, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PatchDocumentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(PatchDocumentsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>Query Lambdas fetched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdasInCollectionAsync(string workspace, string collection)
        {
            return ListQueryLambdasInCollectionAsync(workspace, collection, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="collection">name of the collection</param>
        /// <returns>Query Lambdas fetched successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdasInCollectionAsync(string workspace, string collection, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (collection == null)
                throw new System.ArgumentNullException("collection");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/collections/{collection}/lambdas");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{collection}", System.Uri.EscapeDataString(ConvertToString(collection, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListQueryLambdaVersionsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListQueryLambdaVersionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListQueryLambdasResponse> ListQueryLambdasInWorkspaceAsync(string workspace)
        {
            return ListQueryLambdasInWorkspaceAsync(workspace, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambdas</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>Query Lambdas listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListQueryLambdasResponse> ListQueryLambdasInWorkspaceAsync(string workspace, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListQueryLambdasResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListQueryLambdasResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryLambdaVersionResponse> CreateQueryLambdaAsync(string workspace, CreateQueryLambdaRequest body)
        {
            return CreateQueryLambdaAsync(workspace, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryLambdaVersionResponse> CreateQueryLambdaAsync(string workspace, CreateQueryLambdaRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryLambdaVersionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryLambdaVersionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>Query Lambda deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteQueryLambdaResponse> DeleteQueryLambdaAsync(string workspace, string queryLambda)
        {
            return DeleteQueryLambdaAsync(workspace, queryLambda, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>Query Lambda deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteQueryLambdaResponse> DeleteQueryLambdaAsync(string workspace, string queryLambda, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteQueryLambdaResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DeleteQueryLambdaResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Query Lambda Tags</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListQueryLambdaTagsAsync(string workspace, string queryLambda)
        {
            return ListQueryLambdaTagsAsync(workspace, queryLambda, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Tags</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>tags listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListQueryLambdaTagsResponse> ListQueryLambdaTagsAsync(string workspace, string queryLambda, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListQueryLambdaTagsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListQueryLambdaTagsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>tag created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryLambdaTagResponse> CreateQueryLambdaTagAsync(string workspace, string queryLambda, CreateQueryLambdaTagRequest body)
        {
            return CreateQueryLambdaTagAsync(workspace, queryLambda, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>tag created successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryLambdaTagResponse> CreateQueryLambdaTagAsync(string workspace, string queryLambda, CreateQueryLambdaTagRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryLambdaTagResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryLambdaTagResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>version retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryLambdaTagResponse> GetQueryLambdaTagVersionAsync(string workspace, string queryLambda, string tag)
        {
            return GetQueryLambdaTagVersionAsync(workspace, queryLambda, tag, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Query Lambda Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>version retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryLambdaTagResponse> GetQueryLambdaTagVersionAsync(string workspace, string queryLambda, string tag, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (tag == null)
                throw new System.ArgumentNullException("tag");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tag}", System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryLambdaTagResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryLambdaTagResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Run Query Lambda By Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">tag</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaByTagAsync(string workspace, string queryLambda, string tag, ExecuteQueryLambdaRequest body)
        {
            return ExecuteQueryLambdaByTagAsync(workspace, queryLambda, tag, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Run Query Lambda By Tag</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">tag</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaByTagAsync(string workspace, string queryLambda, string tag, ExecuteQueryLambdaRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (tag == null)
                throw new System.ArgumentNullException("tag");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tag}", System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete Query Lambda Tag Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>tag deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryLambdaTagResponse> DeleteQueryLambdaTagAsync(string workspace, string queryLambda, string tag)
        {
            return DeleteQueryLambdaTagAsync(workspace, queryLambda, tag, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Query Lambda Tag Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="tag">name of the tag</param>
        /// <returns>tag deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryLambdaTagResponse> DeleteQueryLambdaTagAsync(string workspace, string queryLambda, string tag, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (tag == null)
                throw new System.ArgumentNullException("tag");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tag}", System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryLambdaTagResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryLambdaTagResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda version deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryLambdaVersionResponse> DeleteQueryLambdaVersionAsync(string workspace, string queryLambda, string version)
        {
            return DeleteQueryLambdaVersionAsync(workspace, queryLambda, version, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda version deleted successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryLambdaVersionResponse> DeleteQueryLambdaVersionAsync(string workspace, string queryLambda, string version, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (version == null)
                throw new System.ArgumentNullException("version");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/version/{version}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryLambdaVersionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryLambdaVersionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Query Lambda Versions</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaVersionsAsync(string workspace, string queryLambda)
        {
            return ListQueryLambdaVersionsAsync(workspace, queryLambda, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Query Lambda Versions</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <returns>versions listed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListQueryLambdaVersionsResponse> ListQueryLambdaVersionsAsync(string workspace, string queryLambda, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListQueryLambdaVersionsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListQueryLambdaVersionsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda updated successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryLambdaVersionResponse> UpdateQueryLambdaAsync(string workspace, string queryLambda, UpdateQueryLambdaRequest body, bool? create)
        {
            return UpdateQueryLambdaAsync(workspace, queryLambda, body, create, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda updated successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryLambdaVersionResponse> UpdateQueryLambdaAsync(string workspace, string queryLambda, UpdateQueryLambdaRequest body, bool? create, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions?");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
            if (create != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("create") + "=").Append(System.Uri.EscapeDataString(ConvertToString(create, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryLambdaVersionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryLambdaVersionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryLambdaVersionResponse> GetQueryLambdaVersionAsync(string workspace, string queryLambda, string version)
        {
            return GetQueryLambdaVersionAsync(workspace, queryLambda, version, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Query Lambda Version</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <returns>Query Lambda retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryLambdaVersionResponse> GetQueryLambdaVersionAsync(string workspace, string queryLambda, string version, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (version == null)
                throw new System.ArgumentNullException("version");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryLambdaVersionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryLambdaVersionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Run Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaAsync(string workspace, string queryLambda, string version, ExecuteQueryLambdaRequest body)
        {
            return ExecuteQueryLambdaAsync(workspace, queryLambda, version, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Run Query Lambda</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <param name="queryLambda">name of the Query Lambda</param>
        /// <param name="version">version</param>
        /// <param name="body">JSON object</param>
        /// <returns>Query Lambda executed successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<QueryResponse> ExecuteQueryLambdaAsync(string workspace, string queryLambda, string version, ExecuteQueryLambdaRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            if (queryLambda == null)
                throw new System.ArgumentNullException("queryLambda");
    
            if (version == null)
                throw new System.ArgumentNullException("version");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{queryLambda}", System.Uri.EscapeDataString(ConvertToString(queryLambda, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{version}", System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(QueryResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List Workspaces</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ListWorkspacesResponse> ChildWorkspacesAsync(string workspace)
        {
            return ChildWorkspacesAsync(workspace, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Workspaces</summary>
        /// <param name="workspace">name of the workspace</param>
        /// <returns>workspaces retrieved successfully</returns>
        /// <exception cref="RocksetApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ListWorkspacesResponse> ChildWorkspacesAsync(string workspace, System.Threading.CancellationToken cancellationToken)
        {
            if (workspace == null)
                throw new System.ArgumentNullException("workspace");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/orgs/self/ws/{workspace}/ws");
            urlBuilder_.Replace("{workspace}", System.Uri.EscapeDataString(ConvertToString(workspace, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListWorkspacesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new RocksetApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ListWorkspacesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new RocksetApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new RocksetApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
        
                    return System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AddDocumentsRequest 
    {
        /// <summary>Array of JSON documents</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<object> Data { get; set; } = new System.Collections.ObjectModel.Collection<object>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AddDocumentsResponse 
    {
        /// <summary>information about the added documents</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DocumentStatus> Data { get; set; }
    
    
    }
    
    /// <summary>API keys are used to authenticate requests to Rockset's API. An API key is tied to the user who creates it. A new API key can be created for each use case, with a maximum of 10 API keys per user.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiKey 
    {
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>descriptive label</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>string of 64 alphanumeric characters</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }
    
        /// <summary>ISO-8601 date </summary>
        [Newtonsoft.Json.JsonProperty("last_access_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_access_time { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AwsAccessKey 
    {
        /// <summary>AWS access key ID</summary>
        [Newtonsoft.Json.JsonProperty("aws_access_key_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Aws_access_key_id { get; set; }
    
        /// <summary>AWS secret access key</summary>
        [Newtonsoft.Json.JsonProperty("aws_secret_access_key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Aws_secret_access_key { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AwsRole 
    {
        /// <summary>ARN of rockset-role created in your account</summary>
        [Newtonsoft.Json.JsonProperty("aws_role_arn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Aws_role_arn { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Collection 
    {
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>email of user who created the collection</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>unique identifer for collection, can contain alphanumeric or dash characters</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Za-z0-9_\-.]+$")]
        public string Name { get; set; }
    
        /// <summary>text describing the collection</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>name of the workspace that the collection is in</summary>
        [Newtonsoft.Json.JsonProperty("workspace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Workspace { get; set; }
    
        /// <summary>current status of collection, one of: CREATED, READY, DELETED</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CollectionStatus? Status { get; set; }
    
        /// <summary>list of sources from which collection ingests</summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Source> Sources { get; set; }
    
        /// <summary>metrics about the collection</summary>
        [Newtonsoft.Json.JsonProperty("stats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CollectionStats Stats { get; set; }
    
        /// <summary>number of seconds after which data is purged based on event time</summary>
        [Newtonsoft.Json.JsonProperty("retention_secs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Retention_secs { get; set; }
    
        /// <summary>list of mappings applied on all documents in a collection</summary>
        [Newtonsoft.Json.JsonProperty("field_mappings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FieldMappingV2> Field_mappings { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CollectionStats 
    {
        /// <summary>number of documents in the collection</summary>
        [Newtonsoft.Json.JsonProperty("doc_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Doc_count { get; set; }
    
        /// <summary>total collection size in bytes</summary>
        [Newtonsoft.Json.JsonProperty("total_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_size { get; set; }
    
        /// <summary>number between 0 and 1 that indicates progress of collection creation</summary>
        [Newtonsoft.Json.JsonProperty("fill_progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Fill_progress { get; set; }
    
        /// <summary>number of documents purged from the collection</summary>
        [Newtonsoft.Json.JsonProperty("purged_doc_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Purged_doc_count { get; set; }
    
        /// <summary>total collection size in bytes purged</summary>
        [Newtonsoft.Json.JsonProperty("purged_doc_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Purged_doc_size { get; set; }
    
        /// <summary>milliseconds since Unix epoch Jan 1, 1970</summary>
        [Newtonsoft.Json.JsonProperty("last_updated_ms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_updated_ms { get; set; }
    
        /// <summary>milliseconds since Unix epoch Jan 1, 1970</summary>
        [Newtonsoft.Json.JsonProperty("last_queried_ms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_queried_ms { get; set; }
    
        /// <summary>total number of bytes inserted into the collection</summary>
        [Newtonsoft.Json.JsonProperty("bytes_inserted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_inserted { get; set; }
    
        /// <summary>total number of bytes overwritten in writing into the collection</summary>
        [Newtonsoft.Json.JsonProperty("bytes_overwritten", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_overwritten { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateApiKeyRequest 
    {
        /// <summary>descriptive label</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateApiKeyResponse 
    {
        /// <summary>the API key that was created</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiKey Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateCollectionRequest 
    {
        /// <summary>unique identifer for collection, can contain alphanumeric or dash characters</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>text describing the collection</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>list of sources from which to ingest data</summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Source> Sources { get; set; }
    
        /// <summary>number of seconds after which data is purged, based on event time</summary>
        [Newtonsoft.Json.JsonProperty("retention_secs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Retention_secs { get; set; }
    
        /// <summary>configuration for event data</summary>
        [Newtonsoft.Json.JsonProperty("event_time_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventTimeInfo Event_time_info { get; set; }
    
        /// <summary>list of mappings</summary>
        [Newtonsoft.Json.JsonProperty("field_mappings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FieldMappingV2> Field_mappings { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateCollectionResponse 
    {
        /// <summary>collection that was created</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Collection Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateIntegrationRequest 
    {
        /// <summary>descriptive label</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>longer explanation for the integration</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Amazon S3 details, must have one of aws_access_key or aws_role</summary>
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Integration S3 { get; set; }
    
        /// <summary>Amazon Kinesis details, must have one of aws_access_key or aws_role</summary>
        [Newtonsoft.Json.JsonProperty("kinesis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KinesisIntegration Kinesis { get; set; }
    
        /// <summary>Amazon DynamoDB details, must have one of aws_access_key or aws_role</summary>
        [Newtonsoft.Json.JsonProperty("dynamodb", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DynamodbIntegration Dynamodb { get; set; }
    
        /// <summary>Amazon Redshift details</summary>
        [Newtonsoft.Json.JsonProperty("redshift", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RedshiftIntegration Redshift { get; set; }
    
        /// <summary>GCS details</summary>
        [Newtonsoft.Json.JsonProperty("gcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GcsIntegration Gcs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("segment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SegmentIntegration Segment { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaIntegration Kafka { get; set; }
    
        /// <summary>MongoDb details</summary>
        [Newtonsoft.Json.JsonProperty("mongodb", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MongoDbIntegration Mongodb { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateIntegrationResponse 
    {
        /// <summary>integration object that was created</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Integration Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateQueryLambdaRequest 
    {
        /// <summary>Query Lambda name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>optional description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Query Lambda SQL query</summary>
        [Newtonsoft.Json.JsonProperty("sql", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public QueryLambdaSql Sql { get; set; } = new QueryLambdaSql();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateQueryLambdaTagRequest 
    {
        /// <summary>name of Query Lambda tag</summary>
        [Newtonsoft.Json.JsonProperty("tag_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag_name { get; set; }
    
        /// <summary>hash identifying a Query Lambda tag</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateUserRequest 
    {
        /// <summary>user email, must be unique</summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Email { get; set; }
    
        /// <summary>List of roles for a given user</summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Roles { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateUserResponse 
    {
        /// <summary>user that was created</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateWorkspaceRequest 
    {
        /// <summary>descriptive label and unique identifier</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>longer explanation for the workspace</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateWorkspaceResponse 
    {
        /// <summary>the workspace that was created</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Workspace Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CsvParams 
    {
        /// <summary>If the first line in every object specifies the column names</summary>
        [Newtonsoft.Json.JsonProperty("firstLineAsColumnNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FirstLineAsColumnNames { get; set; }
    
        /// <summary>a single character that is the column separator</summary>
        [Newtonsoft.Json.JsonProperty("separator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Separator { get; set; }
    
        /// <summary>can be one of: UTF-8, ISO_8859_1, UTF-16</summary>
        [Newtonsoft.Json.JsonProperty("encoding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Encoding { get; set; }
    
        /// <summary>names of columns</summary>
        [Newtonsoft.Json.JsonProperty("columnNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ColumnNames { get; set; }
    
        /// <summary>names of columns</summary>
        [Newtonsoft.Json.JsonProperty("columnTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<ColumnTypes> ColumnTypes { get; set; }
    
        /// <summary>character within which a cell value is enclosed,null character if no such character, default is '"'</summary>
        [Newtonsoft.Json.JsonProperty("quoteChar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string QuoteChar { get; set; }
    
        /// <summary>escape character removes any special meaning from the following character,default is '\'</summary>
        [Newtonsoft.Json.JsonProperty("escapeChar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EscapeChar { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteApiKeyResponse 
    {
        /// <summary>the API key that was deleted</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiKey Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteCollectionResponse 
    {
        /// <summary>collection that was deleted</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Collection Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteDocumentsRequest 
    {
        /// <summary>array of document IDs</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DeleteDocumentsRequestData> Data { get; set; } = new System.Collections.ObjectModel.Collection<DeleteDocumentsRequestData>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteDocumentsRequestData 
    {
        /// <summary>unique document ID</summary>
        [Newtonsoft.Json.JsonProperty("_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string _id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteDocumentsResponse 
    {
        /// <summary>information about deleted documents</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DocumentStatus> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteIntegrationResponse 
    {
        /// <summary>integration object that was deleted</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Integration Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteQueryLambdaResponse 
    {
        /// <summary>Query Lambda details</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambda Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteUserResponse 
    {
        /// <summary>user object that was deleted</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public User Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteWorkspaceResponse 
    {
        /// <summary>the workspace that was deleted</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Workspace Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DocumentStatus 
    {
        /// <summary>collection name</summary>
        [Newtonsoft.Json.JsonProperty("_collection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string _collection { get; set; }
    
        /// <summary>error message, if any</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorModel Error { get; set; }
    
        /// <summary>unique document ID</summary>
        [Newtonsoft.Json.JsonProperty("_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string _id { get; set; }
    
        /// <summary>status, one of ADDED, REPLACED, DELETED, ERROR</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DocumentStatusStatus? Status { get; set; }
    
        /// <summary>unique id used to represent each patch request</summary>
        [Newtonsoft.Json.JsonProperty("patch_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Patch_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DynamodbIntegration 
    {
        /// <summary>credentials for an AWS access key integration</summary>
        [Newtonsoft.Json.JsonProperty("aws_access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AwsAccessKey Aws_access_key { get; set; }
    
        /// <summary>role used for external id type authentication</summary>
        [Newtonsoft.Json.JsonProperty("aws_role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AwsRole Aws_role { get; set; }
    
    
    }
    
    /// <summary>Describes details about an error</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ErrorModel 
    {
        /// <summary>descriptive message about the error</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>category of the error</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ErrorModelType? Type { get; set; }
    
        /// <summary>Line where the error happened (if applicable)</summary>
        [Newtonsoft.Json.JsonProperty("line", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Line { get; set; }
    
        /// <summary>Column where the error happened (if applicable)</summary>
        [Newtonsoft.Json.JsonProperty("column", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Column { get; set; }
    
        /// <summary>Internal trace ID to help with debugging</summary>
        [Newtonsoft.Json.JsonProperty("trace_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Trace_id { get; set; }
    
        /// <summary>ID of the error</summary>
        [Newtonsoft.Json.JsonProperty("error_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EventTimeInfo 
    {
        /// <summary>name of the field containing event time</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Field { get; set; }
    
        /// <summary>format of time field, can be one of: milliseconds_since_epoch, seconds_since_epoch</summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Format { get; set; }
    
        /// <summary>default time zone, in standard IANA format</summary>
        [Newtonsoft.Json.JsonProperty("time_zone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Time_zone { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExecuteQueryLambdaRequest 
    {
        /// <summary>list of named parameters</summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryParameter> Parameters { get; set; }
    
        /// <summary>Row limit to use if no limit specified in the SQL query text</summary>
        [Newtonsoft.Json.JsonProperty("default_row_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Default_row_limit { get; set; }
    
        /// <summary>Whether to generate warnings</summary>
        [Newtonsoft.Json.JsonProperty("generate_warnings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Generate_warnings { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FieldMapping 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FieldMappingV2 
    {
        /// <summary>A user specified string that is a name for this mapping</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>A boolean that determines whether to drop all fields in this document. If set, input and output fields should not be set</summary>
        [Newtonsoft.Json.JsonProperty("is_drop_all_fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_drop_all_fields { get; set; }
    
        /// <summary>A List of InputField for this mapping</summary>
        [Newtonsoft.Json.JsonProperty("input_fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InputField> Input_fields { get; set; }
    
        /// <summary>An OutputField for this mapping</summary>
        [Newtonsoft.Json.JsonProperty("output_field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OutputField Output_field { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FieldMask 
    {
        [Newtonsoft.Json.JsonProperty("input_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Input_path { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        [Newtonsoft.Json.JsonProperty("mask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FieldMaskMask Mask { get; set; }
    
    
    }
    
    /// <summary>Field masking function name + args. The args is a JSON object.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FieldMaskMask 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Args { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FormatParams 
    {
        /// <summary>source data is in json format</summary>
        [Newtonsoft.Json.JsonProperty("json", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Json { get; set; }
    
        [Newtonsoft.Json.JsonProperty("csv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CsvParams Csv { get; set; }
    
        [Newtonsoft.Json.JsonProperty("xml", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public XmlParams Xml { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GcpServiceAccount 
    {
        /// <summary>Contents of JSON Service Account key file</summary>
        [Newtonsoft.Json.JsonProperty("service_account_key_file_json", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Service_account_key_file_json { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GcsIntegration 
    {
        /// <summary>credentials for an AWS key integration</summary>
        [Newtonsoft.Json.JsonProperty("gcp_service_account", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GcpServiceAccount Gcp_service_account { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GetCollectionResponse 
    {
        /// <summary>collection that was requested</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Collection Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GetIntegrationResponse 
    {
        /// <summary>integration object</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Integration Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GetWorkspaceResponse 
    {
        /// <summary>the workspace that was requested</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Workspace Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class InputField 
    {
        /// <summary>The name of a field, parsed as a SQL qualified name</summary>
        [Newtonsoft.Json.JsonProperty("field_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Field_name { get; set; }
    
        /// <summary>Define the behaviour if fieldName is missing or is null</summary>
        [Newtonsoft.Json.JsonProperty("if_missing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InputFieldIf_missing? If_missing { get; set; }
    
        /// <summary>If true, then drop fieldName from the document</summary>
        [Newtonsoft.Json.JsonProperty("is_drop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_drop { get; set; }
    
        /// <summary>Sql parameter name</summary>
        [Newtonsoft.Json.JsonProperty("param", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Param { get; set; }
    
    
    }
    
    /// <summary>Integrations that can be associated with data sources to create collections. Only one type of integration may be specified.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Integration 
    {
        /// <summary>descriptive label and unique identifier</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>longer explanation for the integration</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>list of collections that use the integration</summary>
        [Newtonsoft.Json.JsonProperty("collections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Collection> Collections { get; set; }
    
        /// <summary>email of user who created the integration</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Created_by { get; set; }
    
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>Amazon S3 details, must have one of aws_access_key or aws_role</summary>
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Integration S3 { get; set; }
    
        /// <summary>Amazon Kinesis details, must have one of aws_access_key or aws_role</summary>
        [Newtonsoft.Json.JsonProperty("kinesis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KinesisIntegration Kinesis { get; set; }
    
        /// <summary>Amazon DynamoDB details, must have one of aws_access_key or aws_role</summary>
        [Newtonsoft.Json.JsonProperty("dynamodb", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DynamodbIntegration Dynamodb { get; set; }
    
        /// <summary>Amazon Redshift details</summary>
        [Newtonsoft.Json.JsonProperty("redshift", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RedshiftIntegration Redshift { get; set; }
    
        /// <summary>GCS details</summary>
        [Newtonsoft.Json.JsonProperty("gcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GcsIntegration Gcs { get; set; }
    
        /// <summary>Segment details</summary>
        [Newtonsoft.Json.JsonProperty("segment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SegmentIntegration Segment { get; set; }
    
        /// <summary>Kafka details</summary>
        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaIntegration Kafka { get; set; }
    
        /// <summary>MongoDb details</summary>
        [Newtonsoft.Json.JsonProperty("mongodb", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MongoDbIntegration Mongodb { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class KafkaIntegration 
    {
        /// <summary>Kafka topics to tail</summary>
        [Newtonsoft.Json.JsonProperty("kafka_topic_names", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Kafka_topic_names { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>The status of the Kafka source by topic</summary>
        [Newtonsoft.Json.JsonProperty("source_status_by_topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, StatusKafka> Source_status_by_topic { get; set; }
    
        /// <summary>The format of the Kafka topics being tailed</summary>
        [Newtonsoft.Json.JsonProperty("kafka_data_format", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KafkaIntegrationKafka_data_format Kafka_data_format { get; set; }
    
        /// <summary>segment connection string</summary>
        [Newtonsoft.Json.JsonProperty("connection_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Connection_string { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class KinesisIntegration 
    {
        /// <summary>credentials for an AWS access key integration</summary>
        [Newtonsoft.Json.JsonProperty("aws_access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AwsAccessKey Aws_access_key { get; set; }
    
        /// <summary>details of an AWS cross-account role integration</summary>
        [Newtonsoft.Json.JsonProperty("aws_role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AwsRole Aws_role { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListApiKeysResponse 
    {
        /// <summary>list of API key objects</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiKey> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListCollectionsResponse 
    {
        /// <summary>list of all collections</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Collection> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListIntegrationsResponse 
    {
        /// <summary>list of integration objects</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Integration> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListQueryLambdaTagsResponse 
    {
        /// <summary>list of all tags associated with a Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryLambdaTag> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListQueryLambdaVersionsResponse 
    {
        /// <summary>list of all versions for a particular Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryLambdaVersion> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListQueryLambdasResponse 
    {
        /// <summary>list of all Query Lambdas</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryLambda> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListUsersResponse 
    {
        /// <summary>list of users</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<User> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ListWorkspacesResponse 
    {
        /// <summary>list of workspaces</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Workspace> Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MongoDbIntegration 
    {
        /// <summary>MongoDB connection URI string</summary>
        [Newtonsoft.Json.JsonProperty("connection_uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Connection_uri { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class OrgMembership 
    {
        [Newtonsoft.Json.JsonProperty("organization", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Organization Organization { get; set; } = new Organization();
    
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Roles { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        [Newtonsoft.Json.JsonProperty("invite_state", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OrgMembershipInvite_state Invite_state { get; set; }
    
        [Newtonsoft.Json.JsonProperty("invited_by", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Invited_by { get; set; }
    
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("expires_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Expires_at { get; set; }
    
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Created_at { get; set; }
    
    
    }
    
    /// <summary>An organization in Rockset is a container for users and collections.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Organization 
    {
        /// <summary>unique identifier for the organization</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>name of the organization</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>name of the company</summary>
        [Newtonsoft.Json.JsonProperty("company_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Company_name { get; set; }
    
        /// <summary>organization's unique external ID within Rockset</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rockset_user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rockset_user { get; set; }
    
        /// <summary>org state</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OrganizationState? State { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class OrganizationResponse 
    {
        /// <summary>Organization object</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Organization Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class OutputField 
    {
        /// <summary>The name of a field, parsed as a SQL qualified name </summary>
        [Newtonsoft.Json.JsonProperty("field_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Field_name { get; set; }
    
        /// <summary>The name of a sql function</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SqlExpression Value { get; set; }
    
        /// <summary>Error in Mapping execution: 'skip' or 'fail' </summary>
        [Newtonsoft.Json.JsonProperty("on_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OutputFieldOn_error? On_error { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PatchDocument 
    {
        /// <summary>Unique id of the document which is being patched</summary>
        [Newtonsoft.Json.JsonProperty("_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string _id { get; set; }
    
        /// <summary>List of patch operations</summary>
        [Newtonsoft.Json.JsonProperty("patch", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PatchOperation> Patch { get; set; } = new System.Collections.ObjectModel.Collection<PatchOperation>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PatchDocumentsRequest 
    {
        /// <summary>List of JSON Patch Documents</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PatchDocument> Data { get; set; } = new System.Collections.ObjectModel.Collection<PatchDocument>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PatchDocumentsResponse 
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DocumentStatus> Data { get; set; } = new System.Collections.ObjectModel.Collection<DocumentStatus>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PatchOperation 
    {
        /// <summary>Operation to be performed in this patch</summary>
        [Newtonsoft.Json.JsonProperty("op", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PatchOperationOp Op { get; set; }
    
        /// <summary>JSON-Pointer referencing a location in the target document where theoperation is performed</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }
    
        /// <summary>Value used in the patch operation. Required for add, replace and test operations</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }
    
        /// <summary>JSON-Pointer referencing a location in the target document.Required for copy and move operations</summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string From { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryFieldType 
    {
        /// <summary>name of the field</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>data type of the field</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryLambda 
    {
        /// <summary>workspace of this Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("workspace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Workspace { get; set; }
    
        /// <summary>user that created this Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("last_updated_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_updated_by { get; set; }
    
        /// <summary>ISO-8601 date of when Query Lambda was last updated</summary>
        [Newtonsoft.Json.JsonProperty("last_updated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_updated { get; set; }
    
        /// <summary>Query Lambda name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>number of Query Lambda versions</summary>
        [Newtonsoft.Json.JsonProperty("version_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version_count { get; set; }
    
        /// <summary>collections queried by underlying SQL query</summary>
        [Newtonsoft.Json.JsonProperty("collections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Collections { get; set; }
    
        /// <summary>Query Lambda version details for most recently created version</summary>
        [Newtonsoft.Json.JsonProperty("latest_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambdaVersion Latest_version { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryLambdaSql 
    {
        /// <summary>SQL text</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }
    
        /// <summary>default parameters for this Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("default_parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryParameter> Default_parameters { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryLambdaStats 
    {
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("last_executed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_executed { get; set; }
    
        /// <summary>user who last executed Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("last_executed_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_executed_by { get; set; }
    
        /// <summary>ISO-8601 date of last execution failure</summary>
        [Newtonsoft.Json.JsonProperty("last_execution_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_execution_error { get; set; }
    
        /// <summary>error message associated with last failed execution</summary>
        [Newtonsoft.Json.JsonProperty("last_execution_error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_execution_error_message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryLambdaTag 
    {
        /// <summary>name of Query Lambda tag</summary>
        [Newtonsoft.Json.JsonProperty("tag_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag_name { get; set; }
    
        /// <summary>query lambda version</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambdaVersion Version { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryLambdaTagResponse 
    {
        /// <summary>updated Query Lambda tag</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambdaTag Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryLambdaVersion 
    {
        /// <summary>workspace of this Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("workspace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Workspace { get; set; }
    
        /// <summary>user that created this Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>ISO-8601 date of when Query Lambda was created</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>Query Lambda name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Query Lambda version</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
        /// <summary>optional description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Query Lambda SQL query</summary>
        [Newtonsoft.Json.JsonProperty("sql", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambdaSql Sql { get; set; }
    
        /// <summary>collections queried by underlying SQL query</summary>
        [Newtonsoft.Json.JsonProperty("collections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Collections { get; set; }
    
        /// <summary>status of this Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public QueryLambdaVersionState? State { get; set; }
    
        /// <summary>stats related to this Query Lambda</summary>
        [Newtonsoft.Json.JsonProperty("stats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambdaStats Stats { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryLambdaVersionResponse 
    {
        /// <summary>Query Lambda version details</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambdaVersion Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryParameter 
    {
        /// <summary>name of the field</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>data type of the field</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        /// <summary>literal value of the field</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryRequest 
    {
        /// <summary>details about the query</summary>
        [Newtonsoft.Json.JsonProperty("sql", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryRequestSql Sql { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryRequestSql 
    {
        /// <summary>list of named parameters</summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryParameter> Parameters { get; set; }
    
        /// <summary>SQL query as a string</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }
    
        /// <summary>Row limit to use if no limit specified in the query</summary>
        [Newtonsoft.Json.JsonProperty("default_row_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Default_row_limit { get; set; }
    
        /// <summary>Whether to generate warnings</summary>
        [Newtonsoft.Json.JsonProperty("generate_warnings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Generate_warnings { get; set; }
    
        /// <summary>Whether to generate a performance profile for this query</summary>
        [Newtonsoft.Json.JsonProperty("profiling_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Profiling_enabled { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryResponse 
    {
        /// <summary>unique id for this query</summary>
        [Newtonsoft.Json.JsonProperty("query_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query_id { get; set; }
    
        /// <summary>list of collections queried by the query</summary>
        [Newtonsoft.Json.JsonProperty("collections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Collections { get; set; }
    
        /// <summary>list of objects returned by the query</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<object> Results { get; set; }
    
        /// <summary>meta information about the query</summary>
        [Newtonsoft.Json.JsonProperty("stats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryResponseStats Stats { get; set; }
    
        /// <summary>warnings received from the query</summary>
        [Newtonsoft.Json.JsonProperty("warnings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }
    
        /// <summary>meta information about each column in the result set</summary>
        [Newtonsoft.Json.JsonProperty("column_fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryFieldType> Column_fields { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryResponseStats 
    {
        /// <summary>query time in milliseconds</summary>
        [Newtonsoft.Json.JsonProperty("elapsed_time_ms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Elapsed_time_ms { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RedshiftIntegration 
    {
        /// <summary>AWS access key credentials</summary>
        [Newtonsoft.Json.JsonProperty("aws_access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AwsAccessKey Aws_access_key { get; set; }
    
        /// <summary>Username associated with Redshift cluster</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }
    
        /// <summary>Password associated with Redshift cluster</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }
    
        /// <summary>Redshift Cluster host</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host { get; set; }
    
        /// <summary>Redshift Cluster port</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        public int Port { get; set; }
    
        /// <summary>unload S3 bucket path</summary>
        [Newtonsoft.Json.JsonProperty("s3_bucket_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string S3_bucket_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class S3Integration 
    {
        /// <summary>credentials for an AWS access key integration</summary>
        [Newtonsoft.Json.JsonProperty("aws_access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AwsAccessKey Aws_access_key { get; set; }
    
        /// <summary>details of an AWS cross-account role integration</summary>
        [Newtonsoft.Json.JsonProperty("aws_role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AwsRole Aws_role { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SegmentIntegration 
    {
        /// <summary>segment connection string</summary>
        [Newtonsoft.Json.JsonProperty("connection_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Connection_string { get; set; }
    
    
    }
    
    /// <summary>Details about the data source for the given collection. Only one of the following fields are allowed to be defined. Only collections can act as data sources for views. </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Source 
    {
        /// <summary>name of integration to use</summary>
        [Newtonsoft.Json.JsonProperty("integration_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Integration_name { get; set; }
    
        /// <summary>configuration for ingestion from S3</summary>
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceS3 S3 { get; set; }
    
        /// <summary>configuration for ingestion from kinesis stream</summary>
        [Newtonsoft.Json.JsonProperty("kinesis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceKinesis Kinesis { get; set; }
    
        /// <summary>configuration for ingestion from GCS</summary>
        [Newtonsoft.Json.JsonProperty("gcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceGcs Gcs { get; set; }
    
        /// <summary>configuration for ingestion from Redshift</summary>
        [Newtonsoft.Json.JsonProperty("redshift", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceRedshift Redshift { get; set; }
    
        /// <summary>configuration for ingestion from  a dynamodb table</summary>
        [Newtonsoft.Json.JsonProperty("dynamodb", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceDynamoDb Dynamodb { get; set; }
    
        /// <summary>file upload details</summary>
        [Newtonsoft.Json.JsonProperty("file_upload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceFileUpload File_upload { get; set; }
    
        /// <summary>kafka collection identifier</summary>
        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceKafka Kafka { get; set; }
    
        /// <summary>MongoDB collection details</summary>
        [Newtonsoft.Json.JsonProperty("mongodb", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SourceMongoDb Mongodb { get; set; }
    
        /// <summary>the ingest status of this source</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Status Status { get; set; }
    
        /// <summary>format parameters for data from this source</summary>
        [Newtonsoft.Json.JsonProperty("format_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FormatParams Format_params { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceDynamoDb 
    {
        /// <summary>AWS region name of DynamoDB table, by default us-west-2 is used</summary>
        [Newtonsoft.Json.JsonProperty("aws_region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Aws_region { get; set; }
    
        /// <summary>name of DynamoDB table containing data</summary>
        [Newtonsoft.Json.JsonProperty("table_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Table_name { get; set; }
    
        /// <summary>DynamoDB source status</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StatusDynamoDb Status { get; set; }
    
        /// <summary>Max RCU usage for scan</summary>
        [Newtonsoft.Json.JsonProperty("rcu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rcu { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceFileUpload 
    {
        /// <summary>name of the file</summary>
        [Newtonsoft.Json.JsonProperty("file_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string File_name { get; set; }
    
        /// <summary>size of the file in bytes</summary>
        [Newtonsoft.Json.JsonProperty("file_size", Required = Newtonsoft.Json.Required.Always)]
        public long File_size { get; set; }
    
        /// <summary>time of file upload</summary>
        [Newtonsoft.Json.JsonProperty("file_upload_time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string File_upload_time { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceGcs 
    {
        /// <summary>name of GCS bucket you want to ingest from</summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }
    
        /// <summary>Prefix that selects keys to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceKafka 
    {
        /// <summary>The Kafka topic to be tailed</summary>
        [Newtonsoft.Json.JsonProperty("kafka_topic_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Kafka_topic_name { get; set; }
    
        /// <summary>Kafka source status</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StatusKafka Status { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceKinesis 
    {
        /// <summary>name of kinesis stream</summary>
        [Newtonsoft.Json.JsonProperty("stream_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Stream_name { get; set; }
    
        /// <summary>AWS region name of Kinesis stream, by default us-west-2 is used</summary>
        [Newtonsoft.Json.JsonProperty("aws_region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Aws_region { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceMongoDb 
    {
        /// <summary>MongoDB database name containing this collection</summary>
        [Newtonsoft.Json.JsonProperty("database_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Database_name { get; set; }
    
        /// <summary>MongoDB collection name</summary>
        [Newtonsoft.Json.JsonProperty("collection_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Collection_name { get; set; }
    
        /// <summary>MongoDB source status</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StatusMongoDb Status { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceRedshift 
    {
        /// <summary>name of the database in Redshift Cluster</summary>
        [Newtonsoft.Json.JsonProperty("database", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Database { get; set; }
    
        /// <summary>schema which contains the Redshift table</summary>
        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Schema { get; set; }
    
        /// <summary>name of Redshift table containing data</summary>
        [Newtonsoft.Json.JsonProperty("table_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Table_name { get; set; }
    
        /// <summary>field in Redshift source table to monitor for updates</summary>
        [Newtonsoft.Json.JsonProperty("incremental_field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Incremental_field { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SourceS3 
    {
        /// <summary>Prefix that selects keys to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }
    
        /// <summary>Pattern that selects keys to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("pattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pattern { get; set; }
    
        /// <summary>address of S3 bucket containing data</summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Bucket { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SqlExpression 
    {
        /// <summary>The name of a sql function</summary>
        [Newtonsoft.Json.JsonProperty("sql", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sql { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Status 
    {
        /// <summary>Status of the Source's ingestion, one of: INITIALIZING, WATCHING, PROCESSING, COMPLETED, ERROR</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public StatusState? State { get; set; }
    
        /// <summary>ISO-8601 date when state was triggered</summary>
        [Newtonsoft.Json.JsonProperty("since", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Since { get; set; }
    
        /// <summary>state message</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>ISO-8601 date when source was last processed</summary>
        [Newtonsoft.Json.JsonProperty("last_processed_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_processed_at { get; set; }
    
        /// <summary>last source item processed by ingester</summary>
        [Newtonsoft.Json.JsonProperty("last_processed_item", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_processed_item { get; set; }
    
        /// <summary>Total items processed of source</summary>
        [Newtonsoft.Json.JsonProperty("total_processed_items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_processed_items { get; set; }
    
        /// <summary>ISO-8601 date when last error occurred</summary>
        [Newtonsoft.Json.JsonProperty("last_error_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_error_at { get; set; }
    
        /// <summary>last source item that errored</summary>
        [Newtonsoft.Json.JsonProperty("last_error_item", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_error_item { get; set; }
    
        /// <summary>reason for the last error</summary>
        [Newtonsoft.Json.JsonProperty("last_error_reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_error_reason { get; set; }
    
        /// <summary>Total items that errored</summary>
        [Newtonsoft.Json.JsonProperty("total_error_items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_error_items { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class StatusDynamoDb 
    {
        /// <summary>DynamoDB scan start time</summary>
        [Newtonsoft.Json.JsonProperty("scan_start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scan_start_time { get; set; }
    
        /// <summary>DynamoDb scan end time</summary>
        [Newtonsoft.Json.JsonProperty("scan_end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scan_end_time { get; set; }
    
        /// <summary>Number of records inserted using scan</summary>
        [Newtonsoft.Json.JsonProperty("scan_records_processed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Scan_records_processed { get; set; }
    
        /// <summary>Number of records in DynamoDB table at time of scan</summary>
        [Newtonsoft.Json.JsonProperty("scan_total_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Scan_total_records { get; set; }
    
        /// <summary>state of current ingest for this table</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public StatusDynamoDbState? State { get; set; }
    
        /// <summary>ISO-8601 date when source was last processed</summary>
        [Newtonsoft.Json.JsonProperty("stream_last_processed_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stream_last_processed_at { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class StatusKafka 
    {
        /// <summary>State of the Kafka source</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public StatusKafkaState? State { get; set; }
    
        /// <summary>Time at which the last document was consumed from Kafka</summary>
        [Newtonsoft.Json.JsonProperty("last_consumed_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_consumed_time { get; set; }
    
        /// <summary>Number of documents consumed by this Kafka topic</summary>
        [Newtonsoft.Json.JsonProperty("num_documents_processed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_documents_processed { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class StatusKafkaPartition 
    {
        /// <summary>The number of this partition</summary>
        [Newtonsoft.Json.JsonProperty("partition_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Partition_number { get; set; }
    
        /// <summary>Number of documents consumed by this partition</summary>
        [Newtonsoft.Json.JsonProperty("num_documents_processed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_documents_processed { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class StatusMongoDb 
    {
        /// <summary>MongoDB scan start time</summary>
        [Newtonsoft.Json.JsonProperty("scan_start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scan_start_time { get; set; }
    
        /// <summary>MongoDB scan end time</summary>
        [Newtonsoft.Json.JsonProperty("scan_end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scan_end_time { get; set; }
    
        /// <summary>Number of records inserted using scan</summary>
        [Newtonsoft.Json.JsonProperty("scan_records_processed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Scan_records_processed { get; set; }
    
        /// <summary>Number of records in MongoDB table at time of scan</summary>
        [Newtonsoft.Json.JsonProperty("scan_total_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Scan_total_records { get; set; }
    
        /// <summary>state of current ingest for this table</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public StatusMongoDbState? State { get; set; }
    
        /// <summary>ISO-8601 date when new insert from source was last processed</summary>
        [Newtonsoft.Json.JsonProperty("stream_last_insert_processed_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stream_last_insert_processed_at { get; set; }
    
        /// <summary>ISO-8601 date when update from source was last processed</summary>
        [Newtonsoft.Json.JsonProperty("stream_last_update_processed_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stream_last_update_processed_at { get; set; }
    
        /// <summary>ISO-8601 date when delete from source was last processed</summary>
        [Newtonsoft.Json.JsonProperty("stream_last_delete_processed_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stream_last_delete_processed_at { get; set; }
    
        /// <summary>Number of new records inserted using stream</summary>
        [Newtonsoft.Json.JsonProperty("stream_records_inserted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Stream_records_inserted { get; set; }
    
        /// <summary>Number of new records updated using stream</summary>
        [Newtonsoft.Json.JsonProperty("stream_records_updated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Stream_records_updated { get; set; }
    
        /// <summary>Number of new records deleted using stream</summary>
        [Newtonsoft.Json.JsonProperty("stream_records_deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Stream_records_deleted { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class UpdateQueryLambdaRequest 
    {
        /// <summary>optional description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Query Lambda SQL query</summary>
        [Newtonsoft.Json.JsonProperty("sql", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QueryLambdaSql Sql { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class User 
    {
        /// <summary>ISO-8601 date</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>user email</summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Email { get; set; }
    
        /// <summary>user first name</summary>
        [Newtonsoft.Json.JsonProperty("first_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string First_name { get; set; }
    
        /// <summary>user last name</summary>
        [Newtonsoft.Json.JsonProperty("last_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_name { get; set; }
    
        /// <summary>List of roles for a given user</summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Roles { get; set; }
    
        /// <summary>state of user - NEW / ACTIVE</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string State { get; set; }
    
        [Newtonsoft.Json.JsonProperty("org", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Org { get; set; }
    
        [Newtonsoft.Json.JsonProperty("invite_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public UserInvite_state? Invite_state { get; set; }
    
        [Newtonsoft.Json.JsonProperty("orgs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Organization> Orgs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("org_memberships", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OrgMembership> Org_memberships { get; set; }
    
    
    }
    
    /// <summary>Workspaces are organizational containers for collections.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Workspace 
    {
        /// <summary>ISO-8601 date of when workspace was created</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>email of user who created the workspace</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>descriptive label and unique identifier</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>longer explanation for the workspace</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>number of collections that are immediate children of workspace</summary>
        [Newtonsoft.Json.JsonProperty("collection_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Collection_count { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class XmlParams 
    {
        /// <summary>tag until which xml is ignored</summary>
        [Newtonsoft.Json.JsonProperty("root_tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Root_tag { get; set; }
    
        /// <summary>encoding in which data source is encoded</summary>
        [Newtonsoft.Json.JsonProperty("encoding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Encoding { get; set; }
    
        /// <summary>tags with which documents are identified</summary>
        [Newtonsoft.Json.JsonProperty("doc_tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Doc_tag { get; set; }
    
        /// <summary>tag used for the value when there are attributes in the element having no child</summary>
        [Newtonsoft.Json.JsonProperty("value_tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value_tag { get; set; }
    
        /// <summary>tag to differentiate between attributes and elements</summary>
        [Newtonsoft.Json.JsonProperty("attribute_prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Attribute_prefix { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum CollectionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIALIZED")]
        INITIALIZED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CREATED")]
        CREATED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"READY")]
        READY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAUSED")]
        PAUSED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELETED")]
        DELETED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAUSING")]
        PAUSING = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESUMING")]
        RESUMING = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BULK_INGEST_MODE")]
        BULK_INGEST_MODE = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXITING_BULK_INGEST_MODE")]
        EXITING_BULK_INGEST_MODE = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ColumnTypes
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOOLEAN")]
        BOOLEAN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOOL")]
        BOOL = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTEGER")]
        INTEGER = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INT")]
        INT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FLOAT")]
        FLOAT = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIME")]
        TIME = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATE")]
        DATE = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATETIME")]
        DATETIME = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIMESTAMP")]
        TIMESTAMP = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STRING")]
        STRING = 10,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum DocumentStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ADDED")]
        ADDED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPLACED")]
        REPLACED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELETED")]
        DELETED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PATCHED")]
        PATCHED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ErrorModelType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTHEXCEPTION")]
        AUTHEXCEPTION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VERSIONEXCEPTION")]
        VERSIONEXCEPTION = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTERNALERROR")]
        INTERNALERROR = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALIDINPUT")]
        INVALIDINPUT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOTIMPLEMENTEDYET")]
        NOTIMPLEMENTEDYET = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESOURCEEXCEEDED")]
        RESOURCEEXCEEDED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALREADYEXISTS")]
        ALREADYEXISTS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOTALLOWED")]
        NOTALLOWED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOTFOUND")]
        NOTFOUND = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEPENDENTRESOURCES")]
        DEPENDENTRESOURCES = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"QUERY_ERROR")]
        QUERY_ERROR = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_READY")]
        NOT_READY = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FORBIDDEN")]
        FORBIDDEN = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"QUERY_TIMEOUT")]
        QUERY_TIMEOUT = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTEGRATION_NOT_FOUND")]
        INTEGRATION_NOT_FOUND = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROLE_NOT_FOUND")]
        ROLE_NOT_FOUND = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTION_ERROR")]
        CONNECTION_ERROR = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CREATING")]
        CREATING = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BADREQUEST")]
        BADREQUEST = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RATELIMITEXCEEDED")]
        RATELIMITEXCEEDED = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum InputFieldIf_missing
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SKIP")]
        SKIP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PASS")]
        PASS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum KafkaIntegrationKafka_data_format
    {
        [System.Runtime.Serialization.EnumMember(Value = @"JSON")]
        JSON = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AVRO")]
        AVRO = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OrgMembershipInvite_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
        ACCEPTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRED")]
        EXPIRED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCELLED")]
        CANCELLED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OrganizationState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FREE")]
        FREE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAID")]
        PAID = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRIAL")]
        TRIAL = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRIAL_EXPIRED")]
        TRIAL_EXPIRED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRIAL_DEPLETED")]
        TRIAL_DEPLETED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELETED")]
        DELETED = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OutputFieldOn_error
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SKIP")]
        SKIP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL")]
        FAIL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum PatchOperationOp
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ADD")]
        ADD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPLACE")]
        REPLACE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REMOVE")]
        REMOVE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COPY")]
        COPY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MOVE")]
        MOVE = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEST")]
        TEST = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum QueryLambdaVersionState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_SQL")]
        INVALID_SQL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum StatusState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIALIZING")]
        INITIALIZING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WATCHING")]
        WATCHING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSING")]
        PROCESSING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COMPLETED")]
        COMPLETED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum StatusDynamoDbState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIALIZING")]
        INITIALIZING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCANNING_TABLE")]
        SCANNING_TABLE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSING_STREAM")]
        PROCESSING_STREAM = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum StatusKafkaState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NO_DOCS_YET")]
        NO_DOCS_YET = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DORMANT")]
        DORMANT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum StatusMongoDbState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIALIZING")]
        INITIALIZING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SCANNING_TABLE")]
        SCANNING_TABLE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSING_STREAM")]
        PROCESSING_STREAM = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.21.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum UserInvite_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
        ACCEPTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRED")]
        EXPIRED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCELLED")]
        CANCELLED = 3,
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class RocksetApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public RocksetApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class RocksetApiException<TResult> : RocksetApiException
    {
        public TResult Result { get; private set; }

        public RocksetApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108